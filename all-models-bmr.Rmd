# Mammal Metabolic Rates

## Data

Predictors: body mass interacting with habitat, effect of >10 kg.


### Read in data 

```{r, data-in}
mammal_bmr <- read.csv("data/bmr.csv") 
```


### Cleaning

Rename some variables and create species name from genus and species. 

```{r, data-renaming}
mammal_bmr <- mammal_bmr %>%
  rename(source = Source,
         order = order.corrected,
        # n.animals = Number.of.Animals,
         mass.kg = body.mass..kg.) %>%
  mutate(order = str_to_title(order),
         genus = str_to_title(genus),
         animal = paste(genus, species),
         above.10kg = ifelse(mass.kg >= 10, 'Larger', 'Smaller'))
```

Keep only variables we will be using. And "factor" "chr" variables.

```{r, select-and-factor-data}
mammal_bmr <- mammal_bmr %>%
  dplyr::select(order,
                genus,
                species, 
                common.name,
                mass.kg,
                log10.body.mass,
                log10.bmr,
                diet,
                habitat,
                source,
                animal,
                above.10kg
         ) %>%
  mutate(across(where(is.character), factor)) %>%
  arrange(order, genus, species)
```

### Data Visualization
A few quick graphs just to make sure the data are looking as we expect (error checking).


```{r, create-plot-no-display}
my_scatter_plot <- gf_point(log10.bmr ~ log10.body.mass | habitat,
         color = ~order,
         # size = ~parse_number(n_animals),
         data = mammal_bmr,
         alpha = 0.5) %>%
  gf_theme(legend.position = 'bottom',
           legend.title = element_text(size = 8),
           legend.text = element_text(size = 6)) %>%
  gf_theme(scale_color_viridis_d('Order')) %>%
  gf_labs(x = 'Log10(Mass (kg))',
          y = 'Log10(BMR (kcal/day))') 
```

```{r display-static, warning = FALSE, message = FALSE}
my_scatter_plot
```

```{r disply-interactive, warning = FALSE, message = FALSE}
plotly::ggplotly(my_scatter_plot) %>%
  plotly::layout(legend = list(#orientation = 'h',
                               font = list(size = 6)))
```

## GLS

Will not account for phylogeny at all in the model structure. Predictors: body mass interacting with habitat, effect of >10 kg.

```{r, fit-gls}
lm_model <- lm(log10.bmr ~ log10.body.mass * habitat + 
                 log10.body.mass*above.10kg, # + diet,
                 data = mammal_bmr)
tab_model(lm_model) 
lm_anova_results <- car::Anova(lm_model)
pander(lm_anova_results)
```

For more on formatting the fitted model table see: <https://strengejacke.github.io/sjPlot/articles/tab_model_estimates.html>

### Model Assessment

```{r, assess-gls}
lm_preds <- predict(lm_model, se.fit = TRUE)

mammal_bmr <- mammal_bmr  %>%
  mutate(lm_resids = resid(lm_model),
         lm_fitted = lm_preds$fit,
         lm_fit_lo = lm_preds$fit + 1.96*lm_preds$se.fit,
         lm_fit_hi = lm_preds$fit - 1.96*lm_preds$se.fit)
gf_point(lm_resids ~ lm_fitted, data = mammal_bmr)
acf(resid(lm_model))
gf_dhistogram(~lm_resids, data = mammal_bmr,
              bins = 20) %>%
  gf_fitdistr()
```


### Model Predictions

Any predictors *not shown* in a plot are held constant at their mean or most common value.

```{r, predict-gls}
gf_line(10^lm_fitted ~ 10^log10.body.mass,
         color = ~habitat,
         data = mammal_bmr) %>%
  gf_ribbon(10^lm_fit_lo + 10^lm_fit_hi ~ 10^log10.body.mass,
            color = ~habitat, fill = ~habitat) %>%
  # gf_facet_grid(~ diet) %>% 
  gf_theme(scale_color_manual(values = my_colors)) %>%
  gf_theme(scale_fill_manual(values = my_colors)) %>%
  gf_refine(scale_x_continuous(trans = 'log10'),
            scale_y_continuous(trans = 'log10'))

gf_point(log10.bmr ~ lm_fitted, data = mammal_bmr,
         alpha = 0.1) %>%
  gf_labs(y = 'Observed log10(BMR)',
          x = 'Model-predicted log10(BMR)',
          title = 'Linear Regresssion (no phylogeny)') %>%
  gf_abline(slope = 1, intercept = 0, color = 'black', linetype = 'dashed')
```

Can refine the plot of predictions later on.

## Mixed-effects model 

Will include nested random effects of order/family/genus/species, expecting similarity of observations based on a hierarchy of phylogenetic relatedness, but not in a specified/structured way; only groupings are used, with no sense of (for example) the fact that two orders are thought to be "further" apart than any other two.

```{r, fit-re-model}
# this code may generate warnings that are harmless
# https://stackoverflow.com/questions/67040472/warning-in-every-model-of-glmmtmb-givecsparse
re_model <- glmmTMB(log10.bmr ~ log10.body.mass * habitat +
                      log10.body.mass*above.10kg + # diet +
                      (1 | order/genus/species),
                 data = mammal_bmr)

tab_model(re_model) 
re_anova_results <- car::Anova(re_model)
pander(re_anova_results)
```

### Model Assessment

```{r, predict-assess-re}
re_ave_preds <- predict(re_model, 
                    se.fit = TRUE,
                    re.form = ~0)
re_ind_preds <- predict(re_model,
                        se.fit = TRUE,
                        re.form = NULL)
mammal_bmr <- mammal_bmr %>%
  mutate(re_resids = resid(re_model),
         re_ind_fitted = re_ind_preds$fit,
         re_ave_fitted = re_ave_preds$fit,
         re_ave_lo = re_ave_preds$fit - 1.96*re_ave_preds$se.fit,
         re_ave_hi = re_ave_preds$fit + 1.96*re_ave_preds$se.fit)

# save fitted model and data
saveRDS(mammal_bmr, 'fitted-models/mr-data.RDS')
saveRDS(re_model, 'fitted-models/mr-re-model.RDS')


gf_point(re_resids ~ re_ind_fitted, data = mammal_bmr)
acf(resid(re_model))
gf_dhistogram(~re_resids, data = mammal_bmr) %>%
  gf_fitdistr()
```

### Predictions from Model

```{r, re-predictions-by-habitat, fig.cap = 'Observed and predicted BMR as a function of mass. Lines are model predictions, points are observed data, and shaded areas are 95% confidence intervals. Colored lines are predictions from the mixed-effects model, and black line is based on Kleiber (1947).', fig.width = 8.5, fig.height = 3.5}
mammal_bmr <- mammal_bmr %>%
  mutate(pretty_diet = case_when(diet == 'c'~ 'Carnivore',
                                 diet == 'h' ~ 'Herbivore',
                                 diet == 'o' ~ 'Omnivore'),
         pretty_diet = factor(pretty_diet, levels = c('Herbivore', 'Omnivore', 'Carnivore')),
         Habitat = stringr::str_to_sentence(habitat))

re_preds <- gf_point(10^log10.bmr ~ 10^log10.body.mass,
         color = ~Habitat, data = mammal_bmr,
         size = 0.5, alpha = 0.4,
         text = ~animal) %>%
gf_line(10^re_ave_fitted ~ 10^log10.body.mass,
         color = ~Habitat,
         data = mammal_bmr,
        text = ~Habitat,
        alpha = 1) %>%
  gf_ribbon(10^re_ave_lo + 10^re_ave_hi ~ 10^log10.body.mass,
            color = ~Habitat, fill = ~Habitat,
            text = ~Habitat,
            alpha = 0.4) %>%
  # gf_facet_grid(~ pretty_diet) %>%
  gf_labs(x = 'Body Mass (kg)', y = 'BMR (kcal/day)') %>% 
  gf_theme(scale_color_manual(values = my_colors)) %>%
  gf_theme(scale_fill_manual(values = my_colors)) %>%
  gf_refine(scale_x_continuous(trans = 'log10',
                               labels = scales::label_comma(accuracy = 0.001,
                                                            drop0trailing = TRUE)),
            scale_y_continuous(trans = 'log10',
                               labels = scales::label_comma(accuracy = 0.001,
                                                            drop0trailing = TRUE))
            ) %>%
  gf_theme(plot.margin = unit(c(1,1,1,1), "cm"))
  # Kleiber
  # BMR (Kleiber, 1947): BMR (kcal/day) = 70 * body mass (kg) ^0.75
pub_models <- data.frame(mass = seq(from = 0.001, by = 10, to = 70000)) %>%
  mutate(kleiber_bmr = 70*mass^0.75)

re_preds <- re_preds %>%
  gf_line(kleiber_bmr ~ mass, data = pub_models, color = 'black', 
          text = ~"Kleiber") %>% 
  # c(0,0) corresponds to the “bottom left” and c(1,1) corresponds to the “top right” position
  gf_theme(legend.position = c(0.9, 0.1),
           legend.title = element_blank()) %>%
  gf_theme(plot.margin = unit(c(1,2,1,1), "cm"))

re_preds %>% gf_theme(legend.position='none') %>% ggplotly(tooltip = 'text')
```

```{r, bmr-predictions-by-habitat, fig.show = 'hide', dev = 'jpeg'}
re_preds
```


```{r, pred-vs-fitted-re}
gf_point(log10.bmr ~ re_ind_fitted, data = mammal_bmr,
         alpha = 0.1) %>%
  gf_labs(y = 'Observed log10(BMR)',
          x = 'Model-predicted, Species-specific log10(BMR)',
          title = 'Mixed-effects Model (RE of Order/Genus/Species)') %>%
  gf_abline(slope = 1, intercept = 0, color = 'black', linetype = 'dashed')
```

The graph above is a bit "cheating" as we have a random effect of species, but there are only 1-2 measurements for most of the species (nearly guaranteeing that our estimates will be nearly perfect).  What if we also check out the predictions accounting for the modeled effects of Order and Genus, but predicting for the "average" species in each Genus?

```{r, pred-vs-observed-no-species-re}
no_species <- mammal_bmr %>%
  mutate(species = NA)
re_genus_level_preds <- predict(re_model, 
                    se.fit = TRUE,
                    re.form = NULL,
                    newdata = no_species)

gf_point(log10.bmr ~ re_genus_level_preds$fit, data = mammal_bmr,
         alpha = 0.1) %>%
  gf_labs(y = 'Observed log10(BMR)',
          x = 'Model-predicted, Genus-specific log10(BMR)',
          title = 'Mixed-effects Model (RE of Order/Genus/Species)') %>%
  gf_abline(slope = 1, intercept = 0, color = 'black', linetype = 'dashed')
```

### Alternate version: Mass Weightings

Weight observations by body mass, binned into log mass bins. The goal is to reduce the undue influence of *many* data points collected from very small animals.

```{r, log-mass-bins}
nr <- nrow(mammal_bmr)
mammal_bmr <- mammal_bmr %>%
  mutate(log.mass.bin = cut_width(log10.body.mass,
                                  width = 1,
                                  boundary = log10(0.001))) %>%
  group_by(log.mass.bin) %>%
  mutate(log.mass.weights = 1 / n())

mammal_bmr <- mammal_bmr %>%
  # make weights sum to nrow(mammal_bmr)
  mutate(log.mass.weights = log.mass.weights / sum(mammal_bmr$log.mass.weights) * nrow(mammal_bmr)) %>%
  ungroup()

```


```{r, mass-weighted-re-model}
# this code may generate warnings that are harmless
# https://stackoverflow.com/questions/67040472/warning-in-every-model-of-glmmtmb-givecsparse
wt_re_model <- glmmTMB(log10.bmr ~ log10.body.mass * habitat +
                      log10.body.mass*above.10kg + # diet +
                      (1 | order/genus/species),
                    weights = log.mass.weights,
                 data = mammal_bmr)

tab_model(wt_re_model) 
wt_re_anova_results <- car::Anova(wt_re_model)
pander(wt_re_anova_results)
```

### Alternate version: Massive only

Only include species with body mass of 10 kg or more.

```{r, big-mammals-only}
big_mammal_bmr <- mammal_bmr %>%
  filter(log10.body.mass >= log10(10)) %>%
  mutate(across(where(is.factor), factor)) 
# this code may generate warnings that are harmless
# https://stackoverflow.com/questions/67040472/warning-in-every-model-of-glmmtmb-givecsparse
big_re_model <- glmmTMB(log10.bmr ~ log10.body.mass * habitat + # diet +
                      (1 | order/genus/species),
                      data = big_mammal_bmr)

tab_model(big_re_model) 
big_re_anova_results <- car::Anova(big_re_model)
pander(big_re_anova_results)
```

## PGLS

### Read in Tree Data

```{r, prep-trees, message = FALSE}
#Read in trees from Upham et al

tree_path <- paste("data/upham-trees/Completed_5911sp_topoCons_FBDasZhouEtAl")
tree_files <- list.files(tree_path)

all_trees <- list()

for (i in 1:length(tree_files)){
  all_trees[[i]] <- read.tree(paste0(tree_path, '/',
                                     tree_files[i]))
  if (i == 1){
    treeset <- all_trees[[i]]
  }else{
    treeset <- c(treeset, all_trees[[i]])
  }
}

all_tip_labels <- purrr::map(treeset, "tip.label")
all_tip_labels <- purrr::map(all_tip_labels,
                             function(x) 
                               stringr::str_replace_all(x, pattern = '_',
                                                      replacement = ' '))

# get list of species that are in ALL the trees
for (t in 1:length(all_tip_labels)){
  if (t == 1){
    tip_labs <- all_tip_labels[[t]]
  }else{
    tip_labs <- intersect(tip_labs, all_tip_labels[[t]])
  }
}


                            
# keep only the species in mammal_bmr that are in all the trees
# on 4/14 this removes 1 species.
pgls_data <- mammal_bmr %>%
  mutate(animal = as.character(animal)) %>%
  filter(animal %in% tip_labs) %>%
  droplevels()


taxonomy <- read_csv('data/upham-trees/taxonomy_mamPhy_5911species.csv')

```

Fit models, one model for every tree in our list.

```{r, fit-pgls}
pgls_models <- list()

for (t in c(1:length(treeset))){
  # make sure there is only one row of data per species (why sample and not average -- seems dubious??)
  pgls_rep_data <- pgls_data %>% 
    group_by(animal) %>%
    sample_n(1) %>%
    ungroup
  
  
  #Reduce the tree to only include those species in the data set
  refit_tree <- treeset[[t]]
  refit_tree$tip.label <- str_replace_all(refit_tree$tip.label, '_', ' ')
  refit_tree <- drop.tip(refit_tree, 
                         setdiff(refit_tree$tip.label, 
                                 unique(pgls_rep_data %>% pull(animal))))
  
  #Order the data set so that it is in the same order as the tip labels of the tree
  pgls_rep_data <- left_join(data.frame(tree.tip.label = refit_tree$tip.label),
                             pgls_rep_data,
                             by = c('tree.tip.label' = 'animal'),
                             keep = TRUE)
  
  # fit the model
 pgls_models[[t]] <- tryCatch({
    fittd <- gls(log10.bmr ~ log10.body.mass * habitat + 
                     log10.body.mass * above.10kg, # diet ,
                   correlation = corPagel(value = 0.8, 
                                          phy = refit_tree, 
                                          fixed = FALSE, 
                                          form = ~animal),
                   data = pgls_rep_data)
    },
  error = function(cond){
    message(paste('PGLS fit failed for tree', t))
    return(NULL)
  }
  )
}
pgls_models <- pgls_models[which(lapply(pgls_models, is.null) == FALSE)]
```

Note: we tried to fit `r length(treeset)` PGLS models (each with a different tree); of these, model fitting failed for `r length(treeset) - length(pgls_models)`.

Combine the many PGLS model runs together into one summary combined model according to Rubin's rule.

```{r, mira-pool-pgls}
# as.mira takes the list of models and create an object to be used by the mice package
pgls_mira <- as.mira(pgls_models)  
# # pool summarise the models using Rubin's rule corrected for small samples
pooled_pgls   <- pool(pgls_mira)
pooled_pgls_summ <- summary(pooled_pgls, type = 'all', conf.int = TRUE)

pander(pooled_pgls_summ %>% select(term, estimate, std.error, `2.5 %`, `97.5 %`, lambda, fmi))

pgls_anova <- Anova(pgls_mira)
pander(pgls_anova)


```

Alternative approach: using `MuMIn` to do model averaging. This will weight models according to their information criteria scores instead of weighting them all equally. But we see here the results are nearly identical.

```{r, mumin-avg-pgls}
pgls_avg <- model.avg(pgls_models, 
                      rank = function(x) 1)
```

This gives a model with the same coefficients (same model) that I think we can better make predictions from. The other way (with `pool()`) is better for getting the ANOVA results we wanted. Two ways of getting the same result, in different packages.

For the PGLS model, we also want to extract the estimate of $\Lambda$, which tells us about how the phylogeny is affecting the correlation structure.

Previous approach was to take the mean of the estimates of $\Lambda$ from all the individual fitted models.

```{r, get-lambda}
lambda <- mean(unlist(purrr::map(pgls_models, 
                                 function(x) x$modelStruct$corStruct)))
lambda
```

According to this simple method our estimate is $\hat{\Lambda} =$ `r round(lambda, digits = 3)`.

### Model Assessment

It's not really clear how to even approach this, since we don't really any longer expect the residuals to be normal or independent. And based on the data we know there's not a huge issue with linearity. So...ok?

### Prediction Plots

There's a problem here in that the "pooled" model object does NOT have any information stored anymore about the variance-covariance matrix, which is key for making predictions from the model. So for making predictions we need to use package `MuMIn` and its `model.avg()` function, just weighting equally all the models from all the trees. This results in a fitted single model object from which prediction is possible with `predict()`. From initial inspection the coefficient estimates of the averaged model are the same as the previous version averaged with the `mice` package. 

```{r, pgls-predictions}
pgls_preds <- predict(pgls_avg, 
                    se.fit = TRUE,
                    newdata = mammal_bmr)

mammal_bmr <- mammal_bmr %>%
  mutate(pgls_fitted = pgls_preds$fit,
         pgls_lo = pgls_preds$fit - 1.96*pgls_preds$se.fit,
         pgls_hi = pgls_preds$fit + 1.96*pgls_preds$se.fit
         )

gf_line(pgls_fitted ~ log10.body.mass,
         color = ~habitat,
         data = mammal_bmr) %>%
  gf_ribbon(pgls_lo + pgls_hi ~ log10.body.mass,
            color = ~habitat, fill = ~habitat) %>%
  # gf_facet_grid(~ diet) %>% 
  gf_theme(scale_color_manual(values = my_colors)) %>%
  gf_theme(scale_fill_manual(values = my_colors)) 

gf_point(log10.bmr ~ pgls_fitted,
         data = mammal_bmr,
         alpha = 0.1) %>%
  gf_labs(y = 'Observed log10(BMR)',
          x = 'Model-predicted log10(BMR)',
          title = 'PGLS Model') %>%
  gf_abline(slope = 1, intercept = 0, color = 'black', linetype = 'dashed')

```

Notice that the CIs are wider here than in the original linear regression model. This is because of appropriate incorporation of the fact that the observations are not independent and there's phylogenetic signal in the data.

As far as I know though, there is not a way to make predictions for specific species or taxa that are more accurate and account for the "way" in which the species/taxon tends to deviate from the overall average. Instead, our overall uncertainty is adjusted to account for the dependence that we know is in the data. But we can't (I don't think) decompose it into a random part and a phylogeny part like we can with the random effects; they are both mixed inextricably together.

## Cross-validation

We could consider grouping by by body-mass ranges or phylogeny and then assess predictive accuracy as the measure of "success"

This remains to do.

## What's next?

Want to repeat a similar analysis with other datasets on other response variables of interest in a "physiological hierarchy":

- Stroke volume (sv)
- Heart rate (hr)
- Breathing Freq (bf)
- Tidal volume (tv)

All these are other candidate response variables. We started with metabolism, and want to move on to these other metrics.

Main predictor of interest is `habitat`, controlling for body size and phylogeny: Are aquatic/marine animals *different* in some notable way?

Data sets for these other variables are smaller (about n = 50 species).